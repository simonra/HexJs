<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>HexJs</title>
    <style>
        #GridContainer {
            display: grid;
        }
        [data-type="tile"] {
            border: 1px solid black;
            margin: 1px;
        }
    </style>
    <script>
        const sizeX = 10;
        const sizeY = 10;
        window.addEventListener('load', function() {
            MakeGrid(sizeX,sizeY);
        });
        function MakeGrid(sizeX, sizeY) {
            var GridContainer = document.getElementById("GridContainer");
            for (let x = 0; x < sizeX; x++) {
                // const element = array[x];
                for (let y = 0; y < sizeY; y++) {
                    // const element = array[y];
                    var nextTile = document.createElement("div");
                    // nextTile.classList.add("tile");
                    nextTile.dataset.type = "tile";
                    nextTile.dataset.gridcoordinateX = `${x}`;
                    nextTile.dataset.gridcoordinateY = `${y}`;

                    var coordinate = { column: x, row: y };

                    cubecoords = HexCoordinateSystemConvertionUtilities.GetCubeCoordinates(coordinate)

                    nextTile.dataset.cubecoordinateQ = cubecoords.q;
                    nextTile.dataset.cubecoordinateR = cubecoords.r;
                    nextTile.dataset.cubecoordinateS = cubecoords.s;
                    // nextTile.classList.add("tile");
                    // nextTile.classList.add("xPos")
                    // var xClass = document.createAttribute("class");

                    // nextTile.style.gridRow = ``;
                    nextTile.style.gridColumn = `${(1+x)}`;
                    nextTile.style.gridRow = `${(1+y)}`;

                    // var deletemelater = document.createTextNode(`GC: [${x},${y}]SC: [ToDo]`);
                    nextTile.appendChild(document.createTextNode(`GC:`));
                    nextTile.appendChild(document.createTextNode(`[${x},${y}]`));
                    nextTile.appendChild(document.createElement("br"));
                    nextTile.appendChild(document.createTextNode(`QC:`));
                    nextTile.appendChild(document.createTextNode(`[${cubecoords.q},${cubecoords.r},${cubecoords.s}]`));
                    GridContainer.appendChild(nextTile);
                }
            }
        }

        function PopulateSpiralCoordinateLabels() {
            var tiles = document.getElementById("GridContainer");
        }

        HexCoordinateSystemConvertionUtilities = function() {
            function GetCubeCoordinates(coordinate) {
                var offset = -1; // odd = -1, even = + 1
                var q = coordinate.column - (coordinate.row + offset * (coordinate.row & 1)) / 2;
                var r = coordinate.row;
                var s = -q - r;
                return { q: q , r: r, s: s };
            }

            function GetGridOffsetCoordinates(coordinate)
            {
                var offset = -1; // odd = -1, even = + 1
                var column = coordinate.q + (coordinate.r + offset * (coordinate.r & 1)) / 2;
                var row = coordinate.r;
                return { x: column, y: row };
            }

            return {
                GetCubeCoordinates:GetCubeCoordinates,
                GetGridOffsetCoordinates:GetGridOffsetCoordinates
            }
        }();

        HexCubeCoordUtilities = function() {
            var CubeDirectionVectors = [
                { q: +1, r:  0, s: -1 }, // right (straight) when pointy end up
                { q: +1, r: -1, s:  0 }, // up and right when pointy end up
                { q:  0, r: -1, s: +1 }, // up and left when pointy end up
                { q: -1, r:  0, s: +1 }, // left (straight) when pointy end up
                { q: -1, r: +1, s:  0 }, // down and left when pointy end up
                { q:  0, r: +1, s: -1 }, // down and right when pointy end up
            ];

            function CubeDirection(directionIndex) {
                return CubeDirectionVectors[directionIndex];
            }

            function CubeAdd(coordinate, vector) {
                return {
                    q: coordinate.q + vector.q,
                    r: coordinate.r + vector.r,
                    s: coordinate.s + vector.s
                };
            }

            function CubeNeighbor(cube, direction) {
                return CubeAdd(cube, CubeDirection(direction));
            }

            return {
                CubeDirectionVectors:CubeDirectionVectors,
                CubeDirection:CubeDirection,
                CubeAdd:CubeAdd,
                CubeNeighbor:CubeNeighbor
            }
        }();

        HexSpiralUtilities = function () {
            function GetCenterTile(gridSizeX_zeroIndexed, gridSizeY_zeroIndexed) {
                var xCenter = Math.floor(gridSizeX_zeroIndexed/2);
                var yCenter = Math.floor(gridSizeY_zeroIndexed/2);
                return { x: xCenter, y: yCenter };
            }

            function GetNextTile(currentX, currentY, centerX, centerY) {

            }

            function GetPreviousTile(currentX, currentY, centerX, centerY) {
                if(currentX == centerX && currentY == centerY) {
                    return { x: centerX, y: centerY };
                }
            }

            function CubeScale(coordinate, factor) {
                return {
                    q: coordinate.q * factor,
                    r: coordinate.r * factor,
                    s: coordinate.s * factor
                };
            }

            function CubeRing(centerCoord, radius) {
                var tilePositions = [];
                var startingDirectionIndex = 0;
                var tile = HexCubeCoordUtilities.CubeAdd(
                    centerCoord, CubeScale(HexCubeCoordUtilities.CubeDirection(startingDirectionIndex), radius)
                );
                for (let i = startingDirectionIndex; i < 6 + startingDirectionIndex; i++) {
                    for (let j = 0; j < radius; j++) {
                        tilePositions.push(tile);
                        tile = HexCubeCoordUtilities.CubeNeighbor(tile, ((i + 2) % 6));
                    }
                }

                return tilePositions;
            }

            function CubeSpiral(centerCoord, radius) {
                var tilePositions = [];
                tilePositions.push(centerCoord);
                for (let k = 0; k <= radius; k++) {
                    tilePositions.push(CubeRing(centerCoord, k))
                }
                return tilePositions;
            }

            function SmoothCubeSpiral(centerCoord, radius) {
                var tilePositions = [];
                tilePositions.push(centerCoord);
                for (var k = 1; k <= radius; k++) {
                    var nextRing = CubeRing(centerCoord, k);
                    // debugger;
                    for (let i = 0; i < nextRing.length; i++) {
                        // Rotate the array 1 position further for each ring we go out.
                        // So for the first ring outside the center, do nothing, start at the start.
                        // Then for the second ring, make the list go [last item, first item, second item, ... second to last item].
                        // For the third ring, make it [second to last item, last item, first item, second item, ... third last item].
                        // And so on.
                        var nextIndex = (i + (nextRing.length - k + 1)) % nextRing.length;
                        // var nextIndex = (i + (nextRing.length - 1)) % nextRing.length;
                        tilePositions.push(nextRing[nextIndex]);
                    }
                    // for (var i = 0; i < k; i++) {
                    //     var lastElement = nextRing.pop();
                    //     nextRing.unshift(lastElement);
                    //     console.log("we do the shift!");
                    //     // For the spiral to have the effect of "having moved out of the square where the last circle revolution ended",
                    //     // rotate the next ring so that the n'th last element becomes the first,
                    //     // starting with 0 shift for the first ring of radius 1.
                    //     // nextRing.unshift(nextRing.pop());
                    // }
                    // tilePositions = tilePositions.concat(nextRing);
                }

                return tilePositions;
            }

            return {
                GetCenterTile:GetCenterTile,
                CubeScale:CubeScale,
                CubeRing:CubeRing,
                CubeSpiral:CubeSpiral,
                SmoothCubeSpiral:SmoothCubeSpiral
            }
        }();

        HexTests = function() {
            function TestSmoothSpiral() {
                console.log("Beginning testing of smooth spiral generation");
                // var originPoint =  {q: 0, r: 0, s: 0};
                // var firstRing = HexSpiralUtilities.CubeRing(originPoint, 1);
                // var secondRing = HexSpiralUtilities.CubeRing(originPoint, 2);
                var expectedList = [
                    // Origin
                    { q: 0, r: 0, s: 0 },
                    // First ring, no offset
                    { q: 1, r: 0, s: -1 }, // first element
                    { q: 1, r: -1, s: 0 },
                    { q: 0, r: -1, s: 1 },
                    { q: -1, r: 0, s: 1 },
                    { q: -1, r: 1, s: 0 },
                    { q: 0, r: 1, s: -1 }, // last element
                    // Second ring
                    { q: 1, r: 1, s: -2 }, // last element moved to top
                    { q: 2, r: 0, s: -2 }, // first element
                    { q: 2, r: -1, s: -1 },
                    { q: 2, r: -2, s: 0 },
                    { q: 1, r: -2, s: 1 },
                    { q: 0, r: -2, s: 2 },
                    { q: -1, r: -1, s: 2 },
                    { q: -2, r: 0, s: 2 },
                    { q: -2, r: 1, s: 1 },
                    { q: -2, r: 2, s: 0 },
                    { q: -1, r: 2, s: -1 },
                    { q: 0, r: 2, s: -2 }, // second last element
                    // Third ring
                    { q: 1, r: 2, s: -3 }, // second last element
                    { q: 2, r: 1, s: -3 }, // last element
                    { q: 3, r: 0, s: -3 }, // first element
                    { q: 3, r: -1, s: -2 },
                    { q: 3, r: -2, s: -1 },
                    { q: 3, r: -3, s: 0 },
                    { q: 2, r: -3, s: 1 },
                    { q: 1, r: -3, s: 2 },
                    { q: 0, r: -3, s: 3 },
                    { q: -1, r: -2, s: 3 },
                    { q: -2, r: -1, s: 3 },
                    { q: -3, r: 0, s: 3 },
                    { q: -3, r: 1, s: 2 },
                    { q: -3, r: 2, s: 1 },
                    { q: -3, r: 3, s: 0 },
                    { q: -2, r: 3, s: -1 },
                    { q: -1, r: 3, s: -2 },
                    { q: 0, r: 3, s: -3 }, // third last element
                    // Fourth ring
                    { q: 1, r: 3, s: -4 }, // third last element
                    { q: 2, r: 2, s: -4 }, // second last element
                    { q: 3, r: 1, s: -4 }, // last element
                    { q: 4, r: 0, s: -4 }, // first element
                    { q: 4, r: -1, s: -3 },
                    { q: 4, r: -2, s: -2 },
                    { q: 4, r: -3, s: -1 },
                    { q: 4, r: -4, s: 0 },
                    { q: 3, r: -4, s: 1 },
                    { q: 2, r: -4, s: 2 },
                    { q: 1, r: -4, s: 3 },
                    { q: 0, r: -4, s: 4 },
                    { q: -1, r: -3, s: 4 },
                    { q: -2, r: -2, s: 4 },
                    { q: -3, r: -1, s: 4 },
                    { q: -4, r: 0, s: 4 },
                    { q: -4, r: 1, s: 3 },
                    { q: -4, r: 2, s: 2 },
                    { q: -4, r: 3, s: 1 },
                    { q: -4, r: 4, s: 0 },
                    { q: -3, r: 4, s: -1 },
                    { q: -2, r: 4, s: -2 },
                    { q: -1, r: 4, s: -3 },
                    { q: 0, r: 4, s: -4 }, // fourth last element
                ];

                // Act
                var radius = 4;
                var originPoint =  {q: 0, r: 0, s: 0};
                var actual = HexSpiralUtilities.SmoothCubeSpiral(originPoint, radius);

                // Assert
                console.assert(actual.length == expectedList.length, "Resulting list of tiles did not contain expected number of entries.");

                // Make it easier to tweak the radius number above to see if anything changes with more or less circles
                var numberOfItemsToTest = Math.min(expectedList.length, actual.length);

                for (let i = 0; i < numberOfItemsToTest; i++) {
                    var nextItemIsEqual = expectedList[i].q == actual[i].q
                        && expectedList[i].r == actual[i].r
                        && expectedList[i].s == actual[i].s
                        ;
                    console.assert(nextItemIsEqual, `Items at position ${i} did not match.`, { expected: expectedList[i], actual: actual[i]});
                }

                console.log("Done testing smooth spiral generation");
            }

            return {
                TestSmoothSpiral:TestSmoothSpiral
            }
        }();

        HexNeighbourUtilities = function() {
            function GetCoordinatesOfTileToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileAboveAndToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY - 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileAboveAndToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY - 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileBelowAndToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY + 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileBelowAndToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY + 1;
                return { x: neighbourX, y: neighbourY };
            }

            return {
                GetCoordinatesOfTileToTheLeft:GetCoordinatesOfTileToTheLeft,
                GetCoordinatesOfTileToTheRight:GetCoordinatesOfTileToTheRight,
                GetCoordinatesOfTileAboveAndToTheLeft:GetCoordinatesOfTileAboveAndToTheLeft,
                GetCoordinatesOfTileAboveAndToTheRight:GetCoordinatesOfTileAboveAndToTheRight,
                GetCoordinatesOfTileBelowAndToTheLeft:GetCoordinatesOfTileBelowAndToTheLeft,
                GetCoordinatesOfTileBelowAndToTheRight:GetCoordinatesOfTileBelowAndToTheRight,
            }
        }();
    </script>
</head>
<body>
<div id="GridContainer"></div>
<h1>"start()" in console and enter</h1>
</body>
</html>
