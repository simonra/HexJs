<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>HexJs</title>
    <style>
        #GridContainer {
            position: relative;
            padding: 15px; /*Same as margin used in individual calculator*/
        }

        [data-type="tile"] {
            text-align: center;
            position: absolute;
            clip-path: polygon(0% 25%, 0% 75%, 50% 100%, 100% 75%, 100% 25%, 50% 0%);
        }
        [data-spiral-index] {
            /* Selector above works! should do the same as .SpiralMember */
            color: darkblue;
        }
        .NotInSpiral {
            /* display: none; */
            opacity: 0.33;
        }
        .EvenRow {

        }
        .OddRow {

        }
        .EvenColumn{
            background-color: aquamarine;
        }
        .OddColumn {
            background-color: coral;
        }
    </style>
    <script>
        // Global constants
        const sizeX = 10;
        const sizeY = 10;
        const sqrt3 = 1.7320508075688772;

        window.addEventListener('load', function() {
            MakeGrid(sizeX,sizeY);
        });

        function MakeGrid(sizeX, sizeY) {
            var GridContainer = document.getElementById("GridContainer");
            for (let x = 0; x < sizeX; x++) {
                // const element = array[x];
                for (let y = 0; y < sizeY; y++) {
                    // const element = array[y];
                    var nextTile = document.createElement("div");
                    // nextTile.classList.add("tile");
                    nextTile.dataset.type = "tile";
                    nextTile.dataset.gridcoordinateX = `${x}`;
                    nextTile.dataset.gridcoordinateY = `${y}`;

                    var coordinate = { column: x, row: y };

                    cubecoords = HexCoordinateSystemConvertionUtilities.GetCubeCoordinates(coordinate)

                    nextTile.dataset.cubecoordinateQ = cubecoords.q;
                    nextTile.dataset.cubecoordinateR = cubecoords.r;
                    nextTile.dataset.cubecoordinateS = cubecoords.s;

                    // Comment out the display here when no longer needed for visual debugging
                    nextTile.appendChild(document.createTextNode(`GC:`));
                    nextTile.appendChild(document.createTextNode(`[${x},${y}]`));
                    nextTile.appendChild(document.createElement("br"));
                    nextTile.appendChild(document.createTextNode(`QC:`));
                    nextTile.appendChild(document.createTextNode(`[${cubecoords.q},${cubecoords.r},${cubecoords.s}]`));
                    GridContainer.appendChild(nextTile);
                }
            }
            PopulateSpiralCoordinates();
            PositioningLib.PutTilesInRightPosition();
        }

        function PopulateSpiralCoordinates() {
            var tiles = document.getElementById("GridContainer").childNodes;
            var centerTile = HexSpiralUtilities.GetCenterTile(sizeX, sizeY);
            var centerTileCubeCoords = HexCoordinateSystemConvertionUtilities.GetCubeCoordinates({row: centerTile.y, column: centerTile.x});
            var spiralCoords = HexSpiralUtilities.SmoothCubeSpiral(centerTileCubeCoords, 4);

            tiles.forEach(tile => {
                tileCubeCoordinate = {
                    q: tile.dataset.cubecoordinateQ,
                    r: tile.dataset.cubecoordinateR,
                    s: tile.dataset.cubecoordinateS
                };
                for (let i = 0; i < spiralCoords.length; i++) {
                    // const element = array[i];
                    if(HexCubeCoordUtilities.CubeEqual(spiralCoords[i], tileCubeCoordinate)) {
                        tile.dataset.spiralIndex = i;

                        // Comment out the display here when no longer needed for visual debugging
                        tile.appendChild(document.createElement("br"));
                        tile.appendChild(document.createTextNode(`SI:`));
                        tile.appendChild(document.createTextNode(`[${i}]`));

                        break;
                    }
                }
            });
        }

        PositioningLib = function() {
            function GetDisplayDimentions() {
                var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                return { width: width, height: height };
            }

            function GetIndividualTileSize() {
                var screenSize = GetDisplayDimentions();
                var thresholdRadius = 15;
                // Because we are in a "pointy size up" system, width is sqrt(3) * radius.
                // var thresholdWidth = Math.sqrt(3) * thresholdRadius;
                var thresholdWidth = sqrt3 * thresholdRadius;
                var thresholdHeight = 2 * thresholdRadius;
                // var thresholdDiameter = 2 * thresholdRadius;

                if(screenSize.width < thresholdWidth * sizeX || screenSize.height < thresholdHeight * sizeY) {
                    return thresholdRadius;
                }

                var margin = 15;

                var availableWidth = screenSize.width - 2 * margin;
                var maxDiameterGivenWidth = availableWidth/sizeX;
                // var maxByWidth = Math.floor(maxDiameterGivenWidth);
                var maxRadiusGivenWidth = maxDiameterGivenWidth/sqrt3;
                var maxByWidth = Math.floor(maxRadiusGivenWidth);

                var availableHeight = screenSize.height - 2 * margin;
                var maxDiameterGivenHeight = availableWidth/sizeX;
                // var maxByHeight = Math.floor(maxDiameterGivenHeight);
                var maxRadiusGivenHeight = maxDiameterGivenHeight/2;
                var maxByHeight = Math.floor(maxRadiusGivenHeight);

                return Math.min(maxByWidth, maxByHeight);
            }

            function SizeContainer(tileSize) {
                var container = document.getElementById("GridContainer");
                var width = tileSize * sizeY;
                var height = tileSize * sizeY;
                container.style.width = `${width}px`;
                container.style.height = `${height}px`;
            }

            function PutTilesInRightPosition() {
                /* ToDo:
                 *  - Find bounding size of screen
                 *  - If below size threshold (15px by 15 px per tile or something like that?)
                 *      - Don't dynmaicaly calculate tile size
                 *  - Calculate size of tiles based on everything fitting within both height and width
                 *  - For each tile, position it in x and y
                 *  - Profit??*/
                var tiles = document.getElementById("GridContainer").childNodes;

                var tileSize = GetIndividualTileSize();
                SizeContainer(tileSize);
                var margin = 15;

                var tileCssWidth = `${tileSize * sqrt3}px`
                var tileCssHeight = `${tileSize * 2}px`

                tiles.forEach(tile => {
                    if(tile.dataset.spiralIndex >= 0) {
                        tile.classList.add("SpiralMember");
                    }
                    else {
                        tile.classList.add("NotInSpiral");
                    }

                    tile.style.width = tileCssWidth;
                    tile.style.height = tileCssHeight;
                    tile.style.maxWidth = tileCssWidth;
                    tile.style.maxHeight = tileCssHeight;
                    // tile.style.minWidth = tileCssWidth;
                    // tile.style.minHeight = tileCssHeight;

                    var gapFactor = 1.075;

                    var topPos = margin + tile.dataset.gridcoordinateY * tileSize * (3/2);
                    var leftPos = margin + tile.dataset.gridcoordinateX * tileSize * sqrt3;
                    topPos *= gapFactor;
                    leftPos *= gapFactor;
                    if(tile.dataset.gridcoordinateY % 2 == 1) {
                        // We are using an odd row offset grid, so move very odd row half a tile to the right
                        leftPos += tileSize - 5;
                    }

                    tile.style.top = `${topPos}px`;
                    tile.style.left = `${leftPos}px`;

                    if(tile.dataset.gridcoordinateY % 2 == 0) {
                        tile.classList.add('EvenRow');
                    } else {
                        tile.classList.add('OddRow');
                    }
                    if (tile.dataset.gridcoordinateX % 2 == 0) {
                        tile.classList.add('EvenColumn');
                    } else {
                        tile.classList.add('OddColumn');
                    }
                });

            }

            return {
                PutTilesInRightPosition:PutTilesInRightPosition
            }
        }();

        HexCoordinateSystemConvertionUtilities = function() {
            function GetCubeCoordinates(coordinate) {
                var offset = -1; // odd = -1, even = + 1
                var q = coordinate.column - (coordinate.row + offset * (coordinate.row & 1)) / 2;
                var r = coordinate.row;
                var s = -q - r;
                return { q: q , r: r, s: s };
            }

            function GetGridOffsetCoordinates(coordinate)
            {
                var offset = -1; // odd = -1, even = + 1
                var column = coordinate.q + (coordinate.r + offset * (coordinate.r & 1)) / 2;
                var row = coordinate.r;
                return { x: column, y: row };
            }

            return {
                GetCubeCoordinates:GetCubeCoordinates,
                GetGridOffsetCoordinates:GetGridOffsetCoordinates
            }
        }();

        HexCubeCoordUtilities = function() {
            var CubeDirectionVectors = [
                { q: +1, r:  0, s: -1 }, // right (straight) when pointy end up
                { q: +1, r: -1, s:  0 }, // up and right when pointy end up
                { q:  0, r: -1, s: +1 }, // up and left when pointy end up
                { q: -1, r:  0, s: +1 }, // left (straight) when pointy end up
                { q: -1, r: +1, s:  0 }, // down and left when pointy end up
                { q:  0, r: +1, s: -1 }, // down and right when pointy end up
            ];

            function CubeDirection(directionIndex) {
                return CubeDirectionVectors[directionIndex];
            }

            function CubeAdd(coordinate, vector) {
                return {
                    q: coordinate.q + vector.q,
                    r: coordinate.r + vector.r,
                    s: coordinate.s + vector.s
                };
            }

            function CubeNeighbor(cube, direction) {
                return CubeAdd(cube, CubeDirection(direction));
            }

            function CubeEqual(first, second) {
                return first.q == second.q && first.r == second.r && first.s == second.s;
            }

            return {
                CubeDirectionVectors:CubeDirectionVectors,
                CubeDirection:CubeDirection,
                CubeAdd:CubeAdd,
                CubeNeighbor:CubeNeighbor,
                CubeEqual:CubeEqual
            }
        }();

        HexSpiralUtilities = function () {
            function GetCenterTile(gridSizeX_zeroIndexed, gridSizeY_zeroIndexed) {
                var xCenter = Math.floor(gridSizeX_zeroIndexed/2);
                var yCenter = Math.floor(gridSizeY_zeroIndexed/2) - 1;
                return { x: xCenter, y: yCenter };
            }

            function CubeScale(coordinate, factor) {
                return {
                    q: coordinate.q * factor,
                    r: coordinate.r * factor,
                    s: coordinate.s * factor
                };
            }

            function CubeRing(centerCoord, radius) {
                var tilePositions = [];
                var startingDirectionIndex = 0;
                var tile = HexCubeCoordUtilities.CubeAdd(
                    centerCoord, CubeScale(HexCubeCoordUtilities.CubeDirection(startingDirectionIndex), radius)
                );
                for (let i = startingDirectionIndex; i < 6 + startingDirectionIndex; i++) {
                    for (let j = 0; j < radius; j++) {
                        tilePositions.push(tile);
                        tile = HexCubeCoordUtilities.CubeNeighbor(tile, ((i + 2) % 6));
                    }
                }

                return tilePositions;
            }

            function CubeSpiral(centerCoord, radius) {
                var tilePositions = [];
                tilePositions.push(centerCoord);
                for (let k = 0; k <= radius; k++) {
                    tilePositions.push(CubeRing(centerCoord, k))
                }
                return tilePositions;
            }

            function SmoothCubeSpiral(centerCoord, radius) {
                var tilePositions = [];
                tilePositions.push(centerCoord);
                for (var k = 1; k <= radius; k++) {
                    var nextRing = CubeRing(centerCoord, k);
                    // debugger;
                    for (let i = 0; i < nextRing.length; i++) {
                        // Rotate the array 1 position further for each ring we go out.
                        // So for the first ring outside the center, do nothing, start at the start.
                        // Then for the second ring, make the list go [last item, first item, second item, ... second to last item].
                        // For the third ring, make it [second to last item, last item, first item, second item, ... third last item].
                        // And so on.
                        var nextIndex = (i + (nextRing.length - k + 1)) % nextRing.length;
                        // var nextIndex = (i + (nextRing.length - 1)) % nextRing.length;
                        tilePositions.push(nextRing[nextIndex]);
                    }
                    // for (var i = 0; i < k; i++) {
                    //     var lastElement = nextRing.pop();
                    //     nextRing.unshift(lastElement);
                    //     console.log("we do the shift!");
                    //     // For the spiral to have the effect of "having moved out of the square where the last circle revolution ended",
                    //     // rotate the next ring so that the n'th last element becomes the first,
                    //     // starting with 0 shift for the first ring of radius 1.
                    //     // nextRing.unshift(nextRing.pop());
                    // }
                    // tilePositions = tilePositions.concat(nextRing);
                }

                return tilePositions;
            }

            return {
                GetCenterTile:GetCenterTile,
                CubeScale:CubeScale,
                CubeRing:CubeRing,
                CubeSpiral:CubeSpiral,
                SmoothCubeSpiral:SmoothCubeSpiral
            }
        }();

        HexTests = function() {
            function TestSmoothSpiral() {
                console.log("Beginning testing of smooth spiral generation");
                // var originPoint =  {q: 0, r: 0, s: 0};
                // var firstRing = HexSpiralUtilities.CubeRing(originPoint, 1);
                // var secondRing = HexSpiralUtilities.CubeRing(originPoint, 2);
                var expectedList = [
                    // Origin
                    { q: 0, r: 0, s: 0 },
                    // First ring, no offset
                    { q: 1, r: 0, s: -1 }, // first element
                    { q: 1, r: -1, s: 0 },
                    { q: 0, r: -1, s: 1 },
                    { q: -1, r: 0, s: 1 },
                    { q: -1, r: 1, s: 0 },
                    { q: 0, r: 1, s: -1 }, // last element
                    // Second ring
                    { q: 1, r: 1, s: -2 }, // last element moved to top
                    { q: 2, r: 0, s: -2 }, // first element
                    { q: 2, r: -1, s: -1 },
                    { q: 2, r: -2, s: 0 },
                    { q: 1, r: -2, s: 1 },
                    { q: 0, r: -2, s: 2 },
                    { q: -1, r: -1, s: 2 },
                    { q: -2, r: 0, s: 2 },
                    { q: -2, r: 1, s: 1 },
                    { q: -2, r: 2, s: 0 },
                    { q: -1, r: 2, s: -1 },
                    { q: 0, r: 2, s: -2 }, // second last element
                    // Third ring
                    { q: 1, r: 2, s: -3 }, // second last element
                    { q: 2, r: 1, s: -3 }, // last element
                    { q: 3, r: 0, s: -3 }, // first element
                    { q: 3, r: -1, s: -2 },
                    { q: 3, r: -2, s: -1 },
                    { q: 3, r: -3, s: 0 },
                    { q: 2, r: -3, s: 1 },
                    { q: 1, r: -3, s: 2 },
                    { q: 0, r: -3, s: 3 },
                    { q: -1, r: -2, s: 3 },
                    { q: -2, r: -1, s: 3 },
                    { q: -3, r: 0, s: 3 },
                    { q: -3, r: 1, s: 2 },
                    { q: -3, r: 2, s: 1 },
                    { q: -3, r: 3, s: 0 },
                    { q: -2, r: 3, s: -1 },
                    { q: -1, r: 3, s: -2 },
                    { q: 0, r: 3, s: -3 }, // third last element
                    // Fourth ring
                    { q: 1, r: 3, s: -4 }, // third last element
                    { q: 2, r: 2, s: -4 }, // second last element
                    { q: 3, r: 1, s: -4 }, // last element
                    { q: 4, r: 0, s: -4 }, // first element
                    { q: 4, r: -1, s: -3 },
                    { q: 4, r: -2, s: -2 },
                    { q: 4, r: -3, s: -1 },
                    { q: 4, r: -4, s: 0 },
                    { q: 3, r: -4, s: 1 },
                    { q: 2, r: -4, s: 2 },
                    { q: 1, r: -4, s: 3 },
                    { q: 0, r: -4, s: 4 },
                    { q: -1, r: -3, s: 4 },
                    { q: -2, r: -2, s: 4 },
                    { q: -3, r: -1, s: 4 },
                    { q: -4, r: 0, s: 4 },
                    { q: -4, r: 1, s: 3 },
                    { q: -4, r: 2, s: 2 },
                    { q: -4, r: 3, s: 1 },
                    { q: -4, r: 4, s: 0 },
                    { q: -3, r: 4, s: -1 },
                    { q: -2, r: 4, s: -2 },
                    { q: -1, r: 4, s: -3 },
                    { q: 0, r: 4, s: -4 }, // fourth last element
                ];

                // Act
                var radius = 4;
                var originPoint =  {q: 0, r: 0, s: 0};
                var actual = HexSpiralUtilities.SmoothCubeSpiral(originPoint, radius);

                // Assert
                console.assert(actual.length == expectedList.length, "Resulting list of tiles did not contain expected number of entries.");

                // Make it easier to tweak the radius number above to see if anything changes with more or less circles
                var numberOfItemsToTest = Math.min(expectedList.length, actual.length);

                for (let i = 0; i < numberOfItemsToTest; i++) {
                    var nextItemIsEqual = expectedList[i].q == actual[i].q
                        && expectedList[i].r == actual[i].r
                        && expectedList[i].s == actual[i].s
                        ;
                    console.assert(nextItemIsEqual, `Items at position ${i} did not match.`, { expected: expectedList[i], actual: actual[i]});
                }

                console.log("Done testing smooth spiral generation");
            }

            return {
                TestSmoothSpiral:TestSmoothSpiral
            }
        }();

        HexNeighbourUtilities = function() {
            function GetCoordinatesOfTileToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileAboveAndToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY - 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileAboveAndToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY - 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileBelowAndToTheLeft(currentX, currentY) {
                var neighbourX = currentX - 1;
                var neighbourY = currentY + 1;
                return { x: neighbourX, y: neighbourY };
            }
            function GetCoordinatesOfTileBelowAndToTheRight(currentX, currentY) {
                var neighbourX = currentX + 1;
                var neighbourY = currentY + 1;
                return { x: neighbourX, y: neighbourY };
            }

            return {
                GetCoordinatesOfTileToTheLeft:GetCoordinatesOfTileToTheLeft,
                GetCoordinatesOfTileToTheRight:GetCoordinatesOfTileToTheRight,
                GetCoordinatesOfTileAboveAndToTheLeft:GetCoordinatesOfTileAboveAndToTheLeft,
                GetCoordinatesOfTileAboveAndToTheRight:GetCoordinatesOfTileAboveAndToTheRight,
                GetCoordinatesOfTileBelowAndToTheLeft:GetCoordinatesOfTileBelowAndToTheLeft,
                GetCoordinatesOfTileBelowAndToTheRight:GetCoordinatesOfTileBelowAndToTheRight,
            }
        }();
    </script>
</head>
<body>
    <h1>"start()" in console and enter</h1>
    <div id="GridContainer"></div>
</body>
</html>
